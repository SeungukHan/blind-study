# 조개 놀이

* 모든 목공은 훌륭하고 튼튼하며 믿을만한 작업대를 필요로 한다.
* 그 작업대는 목공소의 중심이 된다.
* 텍스트 파일들을 다루는 프로그래머에겐 명령어 셸이 작업대가 된다.
* 셸 프롬프트에서 모든 종류의 도구를 불러 쓸 수 있다.
* 파이프를 이용해 원 개발자가 결코 꿈꾸지 못한 방식으로 도구를 결합시키면서 파일을 검색할 수 있다.

## GUI 인터페이스로도 똑같이 잘할 수 있는 것이 아닌가?

* 아니오다.
* GUI로만 작업을 한다면, 가진 황경의 전체 능력을 이용하지 못하게 된다.
* 일반적인 작업을 자동화할 수 도 없고 (스크립트 사용 불가, 크론탭 사용 불가)
* 쓸 수 있는 도구의 풀 파워를 사용할 수 없다. (파이프와의 연계 불가)
* 매크로 도구를 만들 수 없다. (스크립트 사용 불가)
* What You See Is What You Get
    * 보는 것이 얻는 것의 전부
    * 장점이자 곧 단점

## 하지만 우린 GUI에서 제공하는 모델 그 이상을 필요로한다.

* 코드를 자르거나
* 객체 모델을 개발하거나
* 문서를 작성하거나
* 빌드 과정을 자동화하거나
* 혹은 GUI에서 제공하지 않는 쿼리나 기타 작업을 수행하기 위해 몇 개의 명령어를 재빨리 결합할 수 있어야한다.

#### 예시

##### Makefile보다 더 최근에 수정된 모든 .c 파일을 찾아라.
* Shell
```.sh
find . -name '*.c' -newer Makefile -print
```

  * manual page
  ```
  -newer file
               True if the current file has a more recent last modification time than file.
  ```

* GUI
```
탐색시를 열고 해당 디렉터리로 찾아 들어가서, Makefile을 클릭하고 변경 시간을 확인한다. 그 다음 도구/검색을 실행해서, *.c 라고 입력한다.
날짜 탭을 선택하고 첫째 날짜 필드에 기억하고 있는 Makefile의 날짜를 입력한다. 그리고 OK를 누른다.
```

##### 소스의 zip/tar 아카이브를 만들어라.
* Shell
```.sh
zip archive.zip *.h *.c
tar cvf archive.tar *.h *.c
```

* GUI
```
ZIP 유틸리티(쉐어웨어인 WinZip 같은 것)를 불러내 'Create New Archive'를 선택하고,
이름을 입력하고, add 대화상자에서 소스 디렉터리를 선택하고, 필터를 '*.c'라고 하고 'Add'를 클릭한 다음, 다시 '*.h'라고 필터를 변경하고 또 'Add'를 클릭한다.
그리고 아카이브를 닫는다.
```

##### 지난 주 중에 변경되지 않은 자바 파일은 어느 것들인가?

* Shell
```.sh
find . -name '*.java' -mtime +7 print
```

##### 그 중에 어느 파일이 awt 라이브러리를 사용하나?

* Shell
```.sh
find . -name '*.java' -mtime +7 -print | xargs grep 'java.awt'
```


## 쉘을 활용한다면,

* 여러분이 자주하는 일을 일련의 명령어로 자동화할 수 있다.
* 명령어 쉘을 갖고 놀다 보면, 여러분이 얼마나 더 생산적이 될 수 있는지 놀라게 될 것이다.